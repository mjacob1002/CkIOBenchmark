mainmodule iotest {
	include "ckio.h";
	readonly CProxy_Main mainProxy;	 // the proxy to be used
	mainchare Main {
		entry Main(CkArgMsg*);
		entry void ready(Ck::IO::FileReadyMsg* msg);
		entry void startRead(Ck::IO::SessionReadyMsg* msg);
		entry [reductiontarget] void doneReading(CkReductionMsg* msg);
		entry [reductiontarget] void logging(CkReductionMsg* msg);

		entry void postClose(CkReductionMsg* msg){
			serial {
				ckout << "Entered the postClose function\n";
				// sleep (5);
				CkExit();
			}
		}
	
		entry void decrementCount() {
			serial {
				num_reads_done--;
				ckout << "decremented the count to " << num_reads_done << endl;
				if(!num_reads_done){
					CkCallback cb(CkIndex_Main::postClose(0), thisProxy);
					std::cout << "About to enter closing session\n";
					Ck::IO::closeReadSession(current_session, cb);
				}
			}

		}


		
		entry void startReading(){
			serial {
				// ckout << "Starting the reading\n";
				Ck::IO::Options opts;
				opts.numReaders = num_io_buffers;
				CkCallback open_cb(CkIndex_Main::ready(NULL), thisProxy);
				open_cb.setRefNum(0);
				start_time = CkWallTimer(); // start before opening the file
				Ck::IO::open(TEST_FILE, open_cb, opts);
			
			}
			// after the open call, invoke this as the callback
			when ready[0](Ck::IO::FileReadyMsg* msg) serial {
				 _file = msg -> file;
				 CkCallback start_read_session(CkIndex_Main::startRead(NULL), thisProxy);
				 start_read_session.setRefNum(0);
				 // std::vector<int> pes_to_map = {2, 4, 5, 7, 8, 12, 14, 15, 17, 25};	
				 Ck::IO::startReadSession(_file, file_size, 0, start_read_session/*, pes_to_map*/); // load in 100 bytes from offset 0
			}
			// callback that is invoked after the read session is started
			when startRead[0](Ck::IO::SessionReadyMsg* msg) serial {
				CkPrintf("The read session has been set up. Moving on to the reads\n");
				current_session = msg -> session;
				CkCallback test_read_cb(CkIndex_Reader::testRead(0), thisProxy); // this is a bug; you shouldn't use thisProxy. However, I don't invoke this callback so it's ok to leave in for now because I'm too lazy to rework code.	
        CkPrintf("file size is %zu\n",file_size);
				readers = CProxy_Reader::ckNew(msg -> session, file_size, file_size / num_readers, 0, num_readers, num_readers); // create 5 readers which will each read 23 bytes and start from offset 5 i.e 0 will read bytes [5,28), 1 is [10, 33).

			}
		}
	}


	array [1D] Reader {
		entry Reader(Ck::IO::Session session, size_t file_size, size_t bytes, size_t offsets, size_t num_chares);
		entry void verify(std::string test_file);
		// method that verifies the read is correct
		entry void testRead(Ck::IO::ReadCompleteMsg* msg) {
			serial {
				/*
				FILE* fp = fopen("parallel_test.out", "w+");
				fwrite(msg -> data, 1, msg -> bytes, fp);	
				fclose(fp);
				fp = fopen("seq_test.out", "w+");	
				fwrite(msg -> data, 1, msg -> bytes, fp);	
				fclose(fp);

				ckout << "At offset " << msg -> offset << ":";
				char* seq_data = sequentialRead(msg -> offset, msg -> bytes);
				for(size_t i = 0; i< msg -> bytes; ++i){
					CkEnforce(seq_data[i] == msg -> data[i]);
				}
				*/
				// delete[] seq_data;
				// CkPrintf("Chare number %d has reached the testRead function\n", thisIndex);
				CkCallback cb(CkReductionTarget(Main, doneReading), mainProxy);	
				size_t bytes = msg -> bytes;
				// CkPrintf("Reader[%d] read %zu bytes\n", thisIndex, bytes);
				og_msg = msg; // store the msg to be verified later
				contribute(sizeof(bytes), &bytes, CkReduction::nop, cb);
			}

		}

		entry void verifyFullFileRead(std::string test_file, size_t file_size, size_t num_chares);
	}

}
